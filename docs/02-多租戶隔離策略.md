# 多租戶隔離策略設計

## 1. 概述

多租戶架構是SaaS應用的核心設計模式，本文檔詳細描述RBAC系統中的租戶隔離策略，確保不同租戶之間的數據安全和資源隔離。

## 2. 租戶識別機制

### 2.1 租戶識別方式

#### 方式一：子域名識別（推薦）

```
tenant1.yourapp.com  → 租戶ID: tenant1
tenant2.yourapp.com  → 租戶ID: tenant2
```

**優點**：

- 租戶隔離清晰
- 支持獨立配置（SSL證書、DNS）
- 有利於品牌識別

**缺點**：

- 需要DNS配置
- SSL證書管理複雜

#### 方式二：請求頭識別

```
Header: X-Tenant-Id: tenant1
```

**優點**：

- 實現簡單
- 靈活性高

**缺點**：

- 依賴客戶端正確傳遞
- 安全性相對較低

#### 方式三：JWT Token識別（推薦）

```json
{
  "sub": "user123",
  "tenantId": "tenant1",
  "roles": ["ADMIN"],
  "exp": 1700000000
}
```

**優點**：

- 安全性高
- 無需額外請求
- 支持分布式驗證

**缺點**：

- Token體積較大
- 需要刷新機制

### 2.2 租戶上下文管理

#### TenantContext 設計

```java
// 偽代碼示例，僅供理解
public class TenantContext {
    private static final ThreadLocal<String> TENANT_ID = new ThreadLocal<>();
    
    public static void setTenantId(String tenantId);
    public static String getTenantId();
    public static void clear();
}
```

#### TenantFilter 設計流程

```
請求到達
   │
   ├─→ 從請求中提取租戶ID
   │   (子域名/Header/Token)
   │
   ├─→ 驗證租戶是否有效
   │   - 檢查租戶狀態
   │   - 檢查租戶許可證
   │
   ├─→ 設置租戶上下文
   │   TenantContext.set(tenantId)
   │
   ├─→ 執行業務邏輯
   │
   └─→ 清理租戶上下文（⚠️ 必須在finally塊中執行）
       TenantContext.clear()
```

**⚠️ 重要安全警告：ThreadLocal清理機制**

在使用ThreadLocal管理租戶上下文時，必須確保在請求結束後**可靠地清理**線程本地變量，否則可能導致嚴重的數據洩漏問題：

**潛在風險**：

- 應用服務器（如Tomcat、Jetty）使用線程池復用線程
- 如果未清理ThreadLocal，下一個請求可能獲取到上一個租戶的ID
- 這將導致用戶A看到用戶B的數據（嚴重安全事故）

**正確實現示例**：

```java
// 偽代碼示例
@Component
public class TenantFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        try {
            // 1. 提取租戶ID
            String tenantId = extractTenantId(request);
            
            // 2. 驗證租戶
            if (!isValidTenant(tenantId)) {
                throw new UnauthorizedException("Invalid tenant");
            }
            
            // 3. 設置上下文
            TenantContext.setTenantId(tenantId);
            
            // 4. 執行業務邏輯
            chain.doFilter(request, response);
            
        } catch (Exception e) {
            // 處理異常
            handleException(e);
        } finally {
            // ⚠️ 關鍵：無論請求成功或失敗，都必須清理
            TenantContext.clear();
        }
    }
}
```

**測試建議**：

- 編寫單元測試驗證finally塊中的清理邏輯
- 使用線程池模擬並發請求，檢查是否存在線程汙染
- 監控生產環境的ThreadLocal內存洩漏

## 3. 數據隔離策略

### 3.1 隔離級別對比

| 隔離級別 | 數據隔離 | 性能 | 成本 | 適用場景 |
|---------|---------|------|------|---------|
| **數據庫級別** | 完全隔離 | 低 | 高 | 大型企業客戶 |
| **Schema級別** | 邏輯隔離 | 中 | 中 | 中型企業客戶 |
| **表級別（行級別）** | 共享表 | 高 | 低 | 中小型客戶 |
| **混合模式** | 靈活 | 可調 | 可調 | 多層次客戶 |

### 3.2 策略一：行級數據隔離（推薦）

#### 設計原則

- 所有業務表都包含 `tenant_id` 字段
- 所有查詢自動添加租戶過濾條件
- 使用數據庫索引優化查詢性能

#### ⚠️ 性能關鍵：索引設計規範

**必須遵守的索引規則**：

1. **`tenant_id`必須建立索引**：行級隔離方案中，所有表的`tenant_id`字段必須建立索引，否則會導致全表掃描

2. **複合索引中`tenant_id`必須是第一列**：

   ```sql
   -- ✅ 正確：tenant_id在第一位
   CREATE UNIQUE INDEX uk_tenant_username ON sys_user(tenant_id, username);
   
   -- ❌ 錯誤：tenant_id不在第一位，無法利用索引過濾租戶
   CREATE UNIQUE INDEX uk_username_tenant ON sys_user(username, tenant_id);
   ```

3. **性能影響**：
   - 有索引：查詢時間 < 10ms（假設100萬行數據）
   - 無索引：查詢時間 > 5000ms（全表掃描）
   - 性能差異可達**500倍以上**

**索引設計檢查清單**：

- [ ] 所有業務表的`tenant_id`字段已建立單列索引或作為複合索引首列
- [ ] 使用`EXPLAIN`分析查詢計劃，確認使用了索引
- [ ] 監控慢查詢日誌，識別缺少索引的表

#### 表結構設計

```sql
CREATE TABLE sys_user (
    id BIGINT PRIMARY KEY,
    tenant_id VARCHAR(64) NOT NULL,  -- 租戶ID
    username VARCHAR(50) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100),
    status TINYINT DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_tenant_id (tenant_id),
    UNIQUE KEY uk_tenant_username (tenant_id, username)
);
```

#### 自動注入租戶ID

```java
// 使用 JPA/MyBatis 攔截器自動注入
// 所有 INSERT 操作自動添加 tenant_id
// 所有 SELECT/UPDATE/DELETE 自動添加 WHERE tenant_id = ?
```

#### 優點

- 實現成本低
- 資源利用率高
- 維護簡單
- 擴展性好

#### 缺點

- 需要嚴格的代碼規範
- 數據量大時性能影響
- 一定的數據泄露風險

### 3.3 策略二：Schema級別隔離

#### 設計原則

- 每個租戶獨立的Database Schema
- 共享物理數據庫實例
- 動態數據源路由

#### 動態數據源設計

```java
// 偽代碼
public class DynamicDataSourceRouter {
    private Map<String, DataSource> dataSourceMap;
    
    public DataSource determineTargetDataSource() {
        String tenantId = TenantContext.getTenantId();
        return dataSourceMap.get(tenantId);
    }
}
```

#### 租戶初始化流程

```
新租戶註冊
   │
   ├─→ 創建獨立Schema
   │   CREATE SCHEMA tenant_123
   │
   ├─→ 初始化表結構
   │   執行DDL腳本
   │
   ├─→ 初始化基礎數據
   │   默認角色、權限等
   │
   └─→ 註冊到數據源池
       dataSourceMap.put(tenantId, dataSource)
```

#### 優點

- 數據隔離性強
- 支持租戶級別備份恢復
- 可針對租戶優化
- 便於數據遷移

#### 缺點

- 管理複雜度高
- 資源消耗較大
- Schema數量有限制
- 升級維護成本高

### 3.4 策略三：數據庫級別隔離

#### 設計原則

- 每個租戶獨立的物理數據庫
- 適用於高級別客戶
- 支持獨立部署

#### 適用場景

- 對數據安全有極高要求
- 需要獨立部署環境
- 需要獨立性能保證
- 合規性要求（如金融行業）

#### 優點

- 最高級別隔離
- 性能相互獨立
- 完全可定制
- 符合嚴格合規要求

#### 缺點

- 成本最高
- 運維複雜
- 資源利用率低
- 不適合大量小租戶

### 3.5 混合隔離策略（推薦企業方案）

#### 分層策略

```
┌─────────────────────────────────────┐
│  VIP租戶（大型企業）                  │
│  → 獨立數據庫/獨立Schema              │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  標準租戶（中型企業）                 │
│  → 獨立Schema/共享數據庫              │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  基礎租戶（小型企業/試用）            │
│  → 行級隔離/共享表                   │
└─────────────────────────────────────┘
```

#### 租戶分級規則

- **VIP級**：年費 > $10,000 或數據量 > 100GB
- **標準級**：年費 $1,000-$10,000 或數據量 10-100GB
- **基礎級**：年費 < $1,000 或數據量 < 10GB

## 4. 緩存隔離策略

### 4.1 Redis Key設計規範

```
{業務模塊}:{租戶ID}:{業務類型}:{業務ID}

示例：
auth:tenant123:token:user456
user:tenant123:info:user456
permission:tenant123:role:admin
```

### 4.2 緩存命名空間

```java
// 偽代碼
public class TenantCacheKeyGenerator {
    public String generate(String key) {
        String tenantId = TenantContext.getTenantId();
        return String.format("%s:%s", tenantId, key);
    }
}
```

### 4.3 緩存清理策略

- **租戶刪除**：清理該租戶所有緩存
- **用戶登出**：清理該用戶會話緩存
- **權限變更**：清理相關權限緩存
- **定期清理**：設置合理的TTL

## 5. 會話隔離

### 5.1 Session管理

```
Session Key: session:tenant123:user456
Session Data:
{
  "userId": "user456",
  "tenantId": "tenant123",
  "username": "john",
  "roles": ["ADMIN"],
  "permissions": ["user:read", "user:write"],
  "loginTime": "2025-11-21T10:00:00Z",
  "expireTime": "2025-11-21T18:00:00Z"
}
```

### 5.2 Token隔離

- JWT Token包含租戶信息
- 不同租戶使用不同的簽名密鑰（可選）
- Token刷新時驗證租戶狀態

## 6. 文件存儲隔離

### 6.1 目錄結構設計

```
storage/
├── tenant123/
│   ├── avatars/
│   ├── documents/
│   └── exports/
├── tenant456/
│   ├── avatars/
│   ├── documents/
│   └── exports/
```

### 6.2 對象存儲（OSS/S3）

```
Bucket命名：
- 方案1：每個租戶獨立Bucket（適合大租戶）
  - tenant-123-storage
  - tenant-456-storage

- 方案2：共享Bucket，路徑隔離（推薦）
  - app-storage/tenant123/...
  - app-storage/tenant456/...
```

### 6.3 訪問控制

- 文件上傳時自動添加租戶標識
- 文件訪問時驗證租戶權限
- 使用預簽名URL控制訪問時效

## 7. 消息隔離

### 7.1 消息隊列設計

```
Topic命名：
{業務類型}.{租戶ID}

示例：
user.created.tenant123
permission.updated.tenant456
audit.log.tenant123
```

### 7.2 消費者隔離

- 消費消息時提取租戶ID
- 設置租戶上下文
- 處理完成後清理上下文

## 8. 日誌隔離

### 8.1 日誌標識

```json
{
  "timestamp": "2025-11-21T10:00:00Z",
  "tenantId": "tenant123",
  "userId": "user456",
  "traceId": "trace-abc123",
  "level": "INFO",
  "message": "User login successful",
  "module": "auth-module"
}
```

### 8.2 日誌查詢

- 支持按租戶ID過濾
- 租戶管理員只能查看本租戶日誌
- 系統管理員可查看所有日誌

## 9. 安全加固

### 9.1 防止跨租戶訪問

#### 多層驗證

```
請求處理流程：
1. 提取租戶ID（從Token/Header）
2. 驗證租戶狀態（是否啟用）
3. 設置租戶上下文
4. 業務處理（自動過濾租戶數據）
5. 響應前驗證（確保返回數據屬於當前租戶）
```

#### 代碼審查要點

- 所有數據查詢必須包含租戶過濾
- 禁止使用 SELECT * 不帶WHERE條件
- 關聯查詢注意租戶一致性
- API參數中的租戶ID必須與上下文一致

### 9.2 租戶數據加密

#### 敏感數據加密

- 密碼：BCrypt/Argon2加密
- 個人信息：AES加密存儲
- 通信：HTTPS/TLS加密
- 備份：加密後存儲

#### 密鑰管理

- 每個租戶獨立加密密鑰（可選）
- 使用密鑰管理服務（KMS）
- 定期輪換密鑰
- 密鑰訪問審計

## 10. 性能優化

### 10.1 索引優化

```sql
-- 租戶ID作為索引前綴
CREATE INDEX idx_tenant_user ON sys_user(tenant_id, id);
CREATE INDEX idx_tenant_role ON sys_role(tenant_id, role_code);

-- 覆蓋索引減少回表
CREATE INDEX idx_tenant_user_info 
ON sys_user(tenant_id, username, email, status);
```

### 10.2 查詢優化

- 使用分頁查詢
- 避免大範圍掃描
- 合理使用緩存
- 讀寫分離

### 10.3 連接池管理

- 合理設置連接池大小
- 監控連接池使用情況
- 實現連接池動態調整

## 11. 監控與告警

### 11.1 監控指標

#### 租戶級別監控

- 租戶QPS/TPS
- 租戶響應時間
- 租戶錯誤率
- 租戶存儲使用量
- 租戶並發用戶數

#### 系統級別監控

- 總體性能指標
- 數據庫連接數
- 緩存命中率
- 消息隊列堆積

### 11.2 告警策略

```yaml
告警規則：
  - 租戶QPS超過閾值
  - 租戶錯誤率 > 5%
  - 租戶存儲使用 > 80%
  - 跨租戶訪問嘗試
  - 租戶異常登錄行為
```

## 12. 租戶生命週期管理

### 12.1 租戶註冊流程

```
租戶申請
   │
   ├─→ 基本信息驗證
   │   (郵箱、電話、企業信息)
   │
   ├─→ 創建租戶記錄
   │   (生成tenant_id)
   │
   ├─→ 初始化租戶資源
   │   - 創建Schema/表空間
   │   - 初始化默認角色
   │   - 設置默認配置
   │
   ├─→ 創建管理員賬號
   │   (租戶超級管理員)
   │
   └─→ 激活租戶
       (發送激活郵件)
```

### 12.2 租戶升級/降級

- 支持套餐升級
- 功能限制調整
- 存儲配額變更
- 用戶數量調整

### 12.3 租戶遷移

- 支持跨隔離級別遷移
- 數據完整性保證
- 停機時間最小化
- 回滾方案準備

### 12.4 租戶註銷

```
註銷申請
   │
   ├─→ 確認註銷（需管理員確認）
   │
   ├─→ 數據備份
   │   (保留30-90天)
   │
   ├─→ 軟刪除租戶
   │   (標記狀態為DELETED)
   │
   ├─→ 資源釋放
   │   - 清理緩存
   │   - 釋放連接
   │   - 停止計費
   │
   ├─→ 物理資源清理（Schema/Database級隔離）
   │   - 冷靜期結束後執行物理刪除
   │   - DROP SCHEMA {tenant_schema}（Schema級隔離）
   │   - DROP DATABASE {tenant_db}（Database級隔離）
   │   - 釋放存儲空間
   │   - 更新資源配額統計
   │
   └─→ 數據徹底刪除
       - 行級隔離：DELETE FROM tables WHERE tenant_id = ?
       - Schema/Database級：物理刪除Schema/Database
       - 清理備份存儲
       - 審計日誌歸檔
```

## 13. 最佳實踐建議

### 13.1 開發規範

1. **統一使用租戶上下文**：禁止直接傳遞tenant_id參數
2. **所有實體包含租戶字段**：業務表必須有tenant_id
3. **使用攔截器自動注入**：減少人為錯誤
4. **代碼審查關注隔離**：重點檢查跨租戶風險
5. **集成測試覆蓋隔離場景**：驗證隔離有效性

### 13.2 運維規範

1. **租戶數據定期備份**：按照SLA要求
2. **監控租戶資源使用**：防止資源濫用
3. **定期安全審計**：檢查跨租戶訪問日誌
4. **容量規劃**：預估租戶增長
5. **應急預案**：租戶數據恢復方案

### 13.3 測試建議

1. **隔離性測試**：驗證跨租戶數據不可訪問
2. **性能測試**：多租戶並發場景
3. **壓力測試**：單租戶高負載影響
4. **安全測試**：嘗試跨租戶攻擊
5. **數據一致性測試**：租戶遷移場景

## 14. 總結

多租戶隔離策略的選擇需要根據以下因素綜合考慮：

| 考慮因素 | 行級隔離 | Schema隔離 | 數據庫隔離 |
|---------|---------|-----------|-----------|
| **成本** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐ |
| **隔離性** | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **性能** | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **維護性** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐ |
| **擴展性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |

**推薦方案**：

- **初創階段**：行級隔離，快速上線
- **成長階段**：混合策略，分層服務
- **成熟階段**：多種策略並存，滿足不同客戶需求
