# 低耦合設計指南

## 1. 概述

低耦合是構建可維護、可擴展系統的關鍵原則。本文檔提供多租戶RBAC系統的低耦合設計實踐指南。

## 2. 低耦合設計原則

### 2.1 SOLID原則

#### S - 單一職責原則（Single Responsibility Principle）

**定義**：一個類或模塊應該只有一個引起它變化的原因。

**應用場景**：

```
❌ 錯誤示例：UserService 職責過多
class UserService {
    createUser()          // 用戶管理
    authenticateUser()    // 認證
    sendEmail()          // 郵件發送
    exportToExcel()      // 數據導出
    validatePermission() // 權限校驗
}

✅ 正確示例：職責分離
class UserService {
    createUser()
    updateUser()
    deleteUser()
}

class AuthenticationService {
    authenticateUser()
    validateToken()
}

class EmailService {
    sendEmail()
}

class ExportService {
    exportToExcel()
}
```

#### O - 開閉原則（Open-Closed Principle）

**定義**：對擴展開放，對修改關閉。

**應用場景**：

```java
// 策略模式實現租戶隔離策略擴展

// 抽象接口
interface TenantIsolationStrategy {
    void applyIsolation(QueryWrapper query);
}

// 具體實現
class RowLevelIsolation implements TenantIsolationStrategy {
    void applyIsolation(QueryWrapper query) {
        query.eq("tenant_id", TenantContext.getTenantId());
    }
}

class SchemaLevelIsolation implements TenantIsolationStrategy {
    void applyIsolation(QueryWrapper query) {
        // 切換數據源
        DynamicDataSource.switchTo(getTenantSchema());
    }
}

// 使用工廠模式創建
class IsolationStrategyFactory {
    TenantIsolationStrategy create(IsolationType type) {
        switch(type) {
            case ROW: return new RowLevelIsolation();
            case SCHEMA: return new SchemaLevelIsolation();
            case DATABASE: return new DatabaseLevelIsolation();
        }
    }
}
```

#### L - 里氏替換原則（Liskov Substitution Principle）

**定義**：子類必須能夠替換其父類。

**應用場景**：

```java
// 基類
abstract class BaseRepository<T> {
    abstract T findById(Long id);
    abstract List<T> findAll();
    abstract void save(T entity);
}

// 子類可以完全替換父類使用
class UserRepository extends BaseRepository<User> {
    User findById(Long id) { /*...*/ }
    List<User> findAll() { /*...*/ }
    void save(User entity) { /*...*/ }
}
```

#### I - 接口隔離原則（Interface Segregation Principle）

**定義**：客戶端不應該依賴它不需要的接口。

**應用場景**：

```java
// ❌ 錯誤：臃腫的接口
interface UserOperations {
    void create();
    void update();
    void delete();
    void export();
    void import();
    void sendNotification();
}

// ✅ 正確：分離接口
interface UserBasicOperations {
    void create();
    void update();
    void delete();
}

interface UserExportOperations {
    void export();
    void import();
}

interface UserNotificationOperations {
    void sendNotification();
}
```

#### D - 依賴倒置原則（Dependency Inversion Principle）

**定義**：高層模塊不應該依賴低層模塊，兩者都應該依賴抽象。

**應用場景**：

```java
// ❌ 錯誤：直接依賴具體實現
class UserService {
    private MySQLUserRepository repository = new MySQLUserRepository();
}

// ✅ 正確：依賴抽象接口
class UserService {
    private UserRepository repository; // 接口
    
    // 通過構造函數注入
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

// 可以輕易切換實現
UserRepository mysqlRepo = new MySQLUserRepository();
UserRepository mongoRepo = new MongoUserRepository();
```

## 3. 模塊解耦策略

### 3.1 依賴注入（Dependency Injection）

#### Spring依賴注入

```java
// 1. 構造函數注入（推薦）
@Service
public class UserService {
    private final UserRepository userRepository;
    private final RoleService roleService;
    
    @Autowired
    public UserService(UserRepository userRepository, 
                      RoleService roleService) {
        this.userRepository = userRepository;
        this.roleService = roleService;
    }
}

// 2. Setter注入
@Service
public class UserService {
    private UserRepository userRepository;
    
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

// 3. 字段注入（不推薦，難以測試）
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

### 3.2 事件驅動解耦

#### 發布-訂閱模式

```java
// 定義事件
public class UserCreatedEvent extends ApplicationEvent {
    private final User user;
    
    public UserCreatedEvent(Object source, User user) {
        super(source);
        this.user = user;
    }
}

// 發布事件（發布者無需知道訂閱者）
@Service
public class UserService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void createUser(User user) {
        // 業務邏輯
        userRepository.save(user);
        
        // 發布事件
        eventPublisher.publishEvent(new UserCreatedEvent(this, user));
    }
}

// 訂閱事件（多個訂閱者互不影響）
@Component
public class EmailNotificationListener {
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // 發送歡迎郵件
        emailService.sendWelcomeEmail(event.getUser());
    }
}

@Component
public class AuditLogListener {
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // 記錄審計日誌
        auditService.log("User created: " + event.getUser().getId());
    }
}

@Component
public class CacheInvalidationListener {
    @EventListener
    public void handleUserCreated(UserCreatedEvent event) {
        // 清除相關緩存
        cacheManager.evict("users");
    }
}
```

#### 優點

- UserService不需要知道有誰在監聽事件
- 添加新的監聽者不需要修改UserService
- 各監聽者之間完全獨立

### 3.3 消息隊列解耦

#### 異步消息處理

```java
// 生產者
@Service
public class UserService {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void createUser(User user) {
        userRepository.save(user);
        
        // 發送消息到隊列
        UserMessage message = new UserMessage(user);
        rabbitTemplate.convertAndSend("user.exchange", 
                                     "user.created", 
                                     message);
    }
}

// 消費者1：郵件服務
@Component
public class EmailConsumer {
    @RabbitListener(queues = "email.queue")
    public void handleUserCreated(UserMessage message) {
        emailService.sendWelcomeEmail(message.getUser());
    }
}

// 消費者2：統計服務
@Component
public class StatisticsConsumer {
    @RabbitListener(queues = "statistics.queue")
    public void handleUserCreated(UserMessage message) {
        statisticsService.incrementUserCount();
    }
}
```

### 3.4 API Gateway模式

#### 統一入口，服務解耦

```
客戶端
   │
   ▼
┌──────────────────┐
│   API Gateway    │
│  (統一認證授權)    │
└──────────────────┘
   │
   ├─────► Auth Service
   ├─────► User Service
   ├─────► Permission Service
   └─────► Tenant Service
```

**優點**：

- 各服務獨立部署
- 客戶端不直接依賴服務
- 可以獨立擴展各服務
- 統一處理跨域、限流等

## 4. 分層架構解耦

### 4.1 標準分層架構

```
┌────────────────────────────────────┐
│     Controller Layer (控制層)       │
│  - 處理HTTP請求                     │
│  - 參數驗證                         │
│  - 返回響應                         │
└────────────────────────────────────┘
              │ DTO
              ▼
┌────────────────────────────────────┐
│      Service Layer (服務層)         │
│  - 業務邏輯                         │
│  - 事務管理                         │
│  - 權限校驗                         │
└────────────────────────────────────┘
              │ Entity
              ▼
┌────────────────────────────────────┐
│   Repository Layer (數據訪問層)     │
│  - 數據持久化                       │
│  - 查詢操作                         │
└────────────────────────────────────┘
              │
              ▼
┌────────────────────────────────────┐
│         Database (數據庫)           │
└────────────────────────────────────┘
```

### 4.2 層間數據傳輸對象（DTO）

```java
// Controller層：接收請求DTO
public class CreateUserRequest {
    private String username;
    private String email;
    private List<Long> roleIds;
    // getters/setters
}

// Service層：業務實體
public class User {
    private Long id;
    private String username;
    private String email;
    private List<Role> roles;
    // 業務方法
}

// Controller返回：響應DTO
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    private List<String> roleNames;
    // getters/setters
}

// 使用Mapper轉換
@Mapper
public interface UserMapper {
    User toEntity(CreateUserRequest request);
    UserResponse toResponse(User user);
}
```

**好處**：

- 層間解耦
- 避免數據庫實體直接暴露
- 靈活調整各層數據結構
- 易於版本控制

### 4.3 依賴方向

```
依賴方向：Controller → Service → Repository → Entity

規則：
✅ 上層可以依賴下層
✅ 同層之間通過接口依賴
❌ 下層不能依賴上層
❌ 避免循環依賴
```

## 5. 接口抽象與實現分離

### 5.1 定義接口

```java
// 接口定義（在API模塊）
public interface UserService {
    User createUser(CreateUserRequest request);
    User getUserById(Long id);
    List<User> listUsers(UserQuery query);
    void updateUser(Long id, UpdateUserRequest request);
    void deleteUser(Long id);
}

public interface RoleService {
    Role createRole(CreateRoleRequest request);
    void assignPermissions(Long roleId, List<Long> permissionIds);
}
```

### 5.2 實現接口

```java
// 實現類（在實現模塊）
@Service
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final RoleService roleService;
    
    @Autowired
    public UserServiceImpl(UserRepository userRepository,
                          RoleService roleService) {
        this.userRepository = userRepository;
        this.roleService = roleService;
    }
    
    @Override
    public User createUser(CreateUserRequest request) {
        // 實現邏輯
    }
}
```

### 5.3 模塊結構

```
business/
├── user-module/
│   ├── user-api/              # 接口定義
│   │   └── UserService.java
│   └── user-service/          # 接口實現
│       └── UserServiceImpl.java
│
├── role-module/
│   ├── role-api/
│   │   └── RoleService.java
│   └── role-service/
│       └── RoleServiceImpl.java
```

**優點**：

- 其他模塊只依賴API，不依賴實現
- 可以輕鬆替換實現
- 支持多種實現共存
- 便於單元測試（Mock接口）

## 6. 配置外部化

### 6.1 配置文件管理

```yaml
# application.yml
spring:
  profiles:
    active: ${ENV:dev}

---
# application-dev.yml
tenant:
  isolation:
    strategy: ROW  # ROW/SCHEMA/DATABASE
  cache:
    enabled: true
    ttl: 1800

---
# application-prod.yml
tenant:
  isolation:
    strategy: SCHEMA
  cache:
    enabled: true
    ttl: 3600
```

### 6.2 配置類

```java
@Configuration
@ConfigurationProperties(prefix = "tenant")
public class TenantProperties {
    private IsolationConfig isolation;
    private CacheConfig cache;
    
    public static class IsolationConfig {
        private IsolationStrategy strategy;
        // getters/setters
    }
    
    public static class CacheConfig {
        private boolean enabled;
        private int ttl;
        // getters/setters
    }
}

// 使用配置
@Service
public class TenantService {
    @Autowired
    private TenantProperties tenantProperties;
    
    public void process() {
        if (tenantProperties.getCache().isEnabled()) {
            // 使用緩存
        }
    }
}
```

### 6.3 配置中心（可選）

```
應用啟動
   │
   ├─→ 連接配置中心（Nacos/Apollo）
   ├─→ 拉取配置
   ├─→ 監聽配置變更
   └─→ 動態刷新配置
```

## 7. 數據庫訪問解耦

### 7.1 Repository接口

```java
// 定義Repository接口
public interface UserRepository {
    User findById(Long id);
    List<User> findByTenantId(Long tenantId);
    void save(User user);
    void update(User user);
    void delete(Long id);
}

// JPA實現
@Repository
public class JpaUserRepository implements UserRepository {
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }
}

// MyBatis實現
@Repository
public class MyBatisUserRepository implements UserRepository {
    @Autowired
    private UserMapper userMapper;
    
    @Override
    public User findById(Long id) {
        return userMapper.selectById(id);
    }
}
```

### 7.2 動態數據源切換

```java
// 數據源路由
public class DynamicDataSourceRouter extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        String tenantId = TenantContext.getTenantId();
        IsolationLevel level = tenantProperties.getIsolationLevel();
        
        if (level == IsolationLevel.DATABASE || 
            level == IsolationLevel.SCHEMA) {
            return tenantId;
        }
        return "default";
    }
}

// 配置多數據源
@Configuration
public class DataSourceConfig {
    @Bean
    public DataSource dynamicDataSource() {
        DynamicDataSourceRouter router = new DynamicDataSourceRouter();
        
        Map<Object, Object> dataSources = new HashMap<>();
        dataSources.put("default", createDefaultDataSource());
        // 動態添加租戶數據源
        
        router.setTargetDataSources(dataSources);
        router.setDefaultTargetDataSource(dataSources.get("default"));
        
        return router;
    }
}
```

## 8. 緩存抽象

### 8.1 統一緩存接口

```java
// 緩存接口
public interface CacheService {
    <T> T get(String key, Class<T> type);
    void set(String key, Object value, long ttl);
    void delete(String key);
    void deletePattern(String pattern);
}

// Redis實現
@Service
public class RedisCacheService implements CacheService {
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public <T> T get(String key, Class<T> type) {
        return (T) redisTemplate.opsForValue().get(key);
    }
}

// Caffeine本地緩存實現
@Service
public class LocalCacheService implements CacheService {
    private Cache<String, Object> cache = Caffeine.newBuilder()
        .maximumSize(10000)
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .build();
        
    @Override
    public <T> T get(String key, Class<T> type) {
        return (T) cache.getIfPresent(key);
    }
}
```

### 8.2 多級緩存

```java
@Service
public class MultiLevelCacheService implements CacheService {
    @Autowired
    private LocalCacheService localCache;
    
    @Autowired
    private RedisCacheService redisCache;
    
    @Override
    public <T> T get(String key, Class<T> type) {
        // Level 1: 本地緩存
        T value = localCache.get(key, type);
        if (value != null) {
            return value;
        }
        
        // Level 2: Redis緩存
        value = redisCache.get(key, type);
        if (value != null) {
            localCache.set(key, value, 300);
            return value;
        }
        
        return null;
    }
}
```

## 9. 異常處理解耦

### 9.1 自定義異常體系

```java
// 基礎異常
public class RbacException extends RuntimeException {
    private String code;
    private String message;
    
    public RbacException(String code, String message) {
        super(message);
        this.code = code;
        this.message = message;
    }
}

// 業務異常
public class BusinessException extends RbacException {
    public BusinessException(String message) {
        super("BUSINESS_ERROR", message);
    }
}

// 權限異常
public class PermissionDeniedException extends RbacException {
    public PermissionDeniedException(String message) {
        super("PERMISSION_DENIED", message);
    }
}

// 租戶異常
public class TenantException extends RbacException {
    public TenantException(String message) {
        super("TENANT_ERROR", message);
    }
}
```

### 9.2 全局異常處理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(
            BusinessException ex) {
        ErrorResponse response = new ErrorResponse(
            ex.getCode(), 
            ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(response);
    }
    
    @ExceptionHandler(PermissionDeniedException.class)
    public ResponseEntity<ErrorResponse> handlePermissionDenied(
            PermissionDeniedException ex) {
        ErrorResponse response = new ErrorResponse(
            ex.getCode(), 
            ex.getMessage()
        );
        return ResponseEntity.status(HttpStatus.FORBIDDEN)
                           .body(response);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(
            Exception ex) {
        // 記錄日誌
        log.error("Unexpected error", ex);
        
        ErrorResponse response = new ErrorResponse(
            "INTERNAL_ERROR", 
            "系統內部錯誤"
        );
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                           .body(response);
    }
}
```

## 10. 單元測試與解耦

### 10.1 Mock依賴

```java
@SpringBootTest
public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private RoleService roleService;
    
    @InjectMocks
    private UserServiceImpl userService;
    
    @Test
    public void testCreateUser() {
        // Arrange
        CreateUserRequest request = new CreateUserRequest();
        request.setUsername("test");
        
        User mockUser = new User();
        mockUser.setId(1L);
        
        when(userRepository.save(any())).thenReturn(mockUser);
        
        // Act
        User result = userService.createUser(request);
        
        // Assert
        assertNotNull(result);
        assertEquals(1L, result.getId());
        verify(userRepository, times(1)).save(any());
    }
}
```

### 10.2 測試配置隔離

```java
@TestConfiguration
public class TestConfig {
    
    @Bean
    @Primary
    public CacheService mockCacheService() {
        return new MockCacheService();
    }
    
    @Bean
    @Primary
    public EmailService mockEmailService() {
        return new MockEmailService();
    }
}

@SpringBootTest(classes = TestConfig.class)
public class IntegrationTest {
    // 使用Mock的服務進行測試
}
```

## 11. 低耦合檢查清單

### 11.1 代碼審查要點

- [ ] 模塊間是否通過接口通信？
- [ ] 是否存在循環依賴？
- [ ] 配置是否外部化？
- [ ] 是否使用依賴注入？
- [ ] 異常處理是否統一？
- [ ] 是否有過多的靜態方法調用？
- [ ] 是否直接依賴具體實現類？
- [ ] 層次依賴方向是否正確？

### 11.2 架構評估指標

| 指標 | 說明 | 目標 |
|-----|------|------|
| **模塊內聚度** | 模塊內部元素的相關性 | 高 |
| **模塊耦合度** | 模塊間的依賴程度 | 低 |
| **依賴深度** | 依賴鏈的長度 | < 3層 |
| **循環依賴** | 是否存在循環依賴 | 0 |
| **接口覆蓋率** | 使用接口的比例 | > 80% |
| **單元測試覆蓋** | 代碼測試覆蓋率 | > 70% |

## 12. 重構建議

### 12.1 識別高耦合代碼

**症狀**：

- 修改一個類需要同時修改多個其他類
- 類之間存在大量的相互調用
- 測試困難，需要啟動整個系統
- 代碼重用性差

### 12.2 重構步驟

```
1. 識別職責
   ├─→ 分析類的職責
   └─→ 找出不相關的職責

2. 提取接口
   ├─→ 定義清晰的接口
   └─→ 隱藏實現細節

3. 依賴注入
   ├─→ 移除直接依賴
   └─→ 使用構造函數注入

4. 事件解耦
   ├─→ 識別耦合點
   └─→ 使用事件替代直接調用

5. 驗證
   ├─→ 運行測試
   └─→ 檢查依賴關係
```

### 12.3 重構示例

```java
// Before: 高耦合
class OrderService {
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 直接調用其他服務
        inventoryService.reduceStock(order.getItems());
        paymentService.processPayment(order);
        emailService.sendConfirmation(order);
        smsService.sendNotification(order);
    }
}

// After: 低耦合
class OrderService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void createOrder(Order order) {
        orderRepository.save(order);
        
        // 發布事件，解耦
        eventPublisher.publishEvent(new OrderCreatedEvent(order));
    }
}

// 各服務獨立處理
@Component
class InventoryEventHandler {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        inventoryService.reduceStock(event.getOrder().getItems());
    }
}

@Component
class PaymentEventHandler {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        paymentService.processPayment(event.getOrder());
    }
}
```

## 13. 總結

低耦合設計的核心要點：

1. **依賴抽象，而非具體實現**
2. **使用依賴注入，避免硬編碼依賴**
3. **事件驅動，減少直接調用**
4. **接口隔離，職責分明**
5. **配置外部化，提高靈活性**
6. **分層清晰，依賴單向**
7. **異常統一處理，避免耦合**
8. **充分測試，保證質量**

通過遵循這些原則和實踐，可以構建一個高度解耦、易於維護和擴展的多租戶RBAC系統。
