# Data Model: 認證授權模組

**Branch**: `001-authentication` | **Date**: 2025-11-25 | **Generated By**: `/speckit.plan` Phase 1

---

## 概述

本文件定義 Authentication Module 的資料模型，包括領域實體、DTO（資料傳輸物件）、JWT Token 結構、Redis 資料結構及 UserContext 介面設計。初版採用 Mock 資料策略，使用 application.yml 配置測試使用者，後續可無縫切換至資料庫實作（JpaUserRepository）。

**設計原則**：

- **依賴倒置**：AuthService 依賴 UserRepository 介面，不依賴具體實作
- **介面隔離**：DTOs 用於 API 層，Entity 用於 Repository 層，不混用
- **不可變性**：UserContext 設計為不可變物件，執行緒安全
- **分層清晰**：Controller (DTO) → Service (Entity) → Repository (Entity)

---

## 一、領域實體 (Entity)

### 1.1 User（使用者實體）

**用途**：表示系統使用者，用於 Mock 資料與未來資料庫整合

```java
package com.rbac.auth.model.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 使用者實體
 * 
 * <p>初版用於 MockUserRepository，後續可擴展為 JPA Entity</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    /**
     * 使用者 ID（唯一標識）
     */
    private Long userId;
    
    /**
     * 使用者名稱（登入帳號，唯一）
     */
    private String username;
    
    /**
     * BCrypt 雜湊後的密碼
     * <p>格式：$2a$10$[53 字元 BCrypt Hash]</p>
     */
    private String passwordHash;
    
    /**
     * 租戶 ID（初版固定為 1，待 Tenant Module 整合後動態設定）
     */
    private Long tenantId;
    
    /**
     * 使用者角色列表（初版固定為 ["ROLE_USER"]，待 Role Module 整合後動態載入）
     */
    private List<String> roles;
    
    /**
     * 帳號狀態
     * <ul>
     *   <li>ACTIVE：啟用中</li>
     *   <li>LOCKED：已鎖定（5 次密碼錯誤）</li>
     *   <li>DISABLED：已停用</li>
     * </ul>
     */
    private UserStatus status;
    
    /**
     * 電子郵件（選擇性，用於密碼重設）
     */
    private String email;
    
    /**
     * 建立時間
     */
    private LocalDateTime createdAt;
    
    /**
     * 最後登入時間
     */
    private LocalDateTime lastLoginAt;
}

/**
 * 使用者狀態列舉
 */
@Getter
@AllArgsConstructor
public enum UserStatus {
    ACTIVE("啟用"),
    LOCKED("鎖定"),
    DISABLED("停用");
    
    private final String description;
}
```

**欄位說明**：

| 欄位 | 類型 | 必填 | 說明 | 初版預設值 |
|------|------|------|------|-----------|
| userId | Long | ✅ | 使用者唯一標識 | Mock: 1, 2, ... |
| username | String | ✅ | 登入帳號（唯一） | Mock: admin, john |
| passwordHash | String | ✅ | BCrypt 雜湊密碼 | Mock: $2a$10$... |
| tenantId | Long | ✅ | 租戶 ID | 固定為 1 |
| roles | List<String> | ✅ | 角色列表 | ["ROLE_USER"] 或 ["ROLE_ADMIN"] |
| status | UserStatus | ✅ | 帳號狀態 | ACTIVE |
| email | String | ❌ | 電子郵件 | null |
| createdAt | LocalDateTime | ✅ | 建立時間 | 當前時間 |
| lastLoginAt | LocalDateTime | ❌ | 最後登入時間 | null（更新於登入成功） |

---

## 二、資料傳輸物件 (DTO)

### 2.1 LoginRequest（登入請求）

**用途**：POST /api/v1/auth/login 的請求 Body

```java
package com.rbac.auth.model.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 登入請求 DTO
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    
    /**
     * 使用者名稱
     */
    @NotBlank(message = "使用者名稱不可為空")
    @Size(min = 3, max = 50, message = "使用者名稱長度須為 3-50 字元")
    private String username;
    
    /**
     * 密碼（明文，僅在傳輸時使用 HTTPS 加密）
     */
    @NotBlank(message = "密碼不可為空")
    @Size(min = 8, max = 128, message = "密碼長度須為 8-128 字元")
    private String password;
    
    /**
     * 驗證碼（選擇性，初版可不實作）
     */
    private String captcha;
}
```

**驗證規則**：

- username：必填，3-50 字元
- password：必填，8-128 字元
- captcha：選擇性（初版可省略，後續擴展防機器人功能）

---

### 2.2 LoginResponse（登入回應）

**用途**：POST /api/v1/auth/login 的成功回應 data 欄位

```java
package com.rbac.auth.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.List;

/**
 * 登入回應 DTO
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {
    
    /**
     * JWT Token（前端需儲存至 localStorage 或 sessionStorage）
     */
    private String token;
    
    /**
     * Token 類型（固定為 "Bearer"）
     */
    private String tokenType = "Bearer";
    
    /**
     * Token 有效期（秒，24 小時 = 86400 秒）
     */
    private Long expiresIn;
    
    /**
     * Token 過期時間戳記（Unix timestamp，單位：秒）
     */
    private Long expiresAt;
    
    /**
     * 使用者 ID
     */
    private Long userId;
    
    /**
     * 使用者名稱
     */
    private String username;
    
    /**
     * 租戶 ID
     */
    private Long tenantId;
    
    /**
     * 使用者角色列表
     */
    private List<String> roles;
}
```

**回應範例**：

```json
{
  "code": 200,
  "message": "登入成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 86400,
    "expiresAt": 1732665600,
    "userId": 1,
    "username": "admin",
    "tenantId": 1,
    "roles": ["ROLE_ADMIN"]
  },
  "timestamp": "2025-11-25T10:30:00Z",
  "traceId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}
```

---

### 2.3 UserInfoResponse（使用者資訊回應）

**用途**：GET /api/v1/auth/me 的回應 data 欄位

```java
package com.rbac.auth.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 使用者資訊回應 DTO
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserInfoResponse {
    
    /**
     * 使用者 ID
     */
    private Long userId;
    
    /**
     * 使用者名稱
     */
    private String username;
    
    /**
     * 租戶 ID
     */
    private Long tenantId;
    
    /**
     * 使用者角色列表
     */
    private List<String> roles;
    
    /**
     * 電子郵件（選擇性）
     */
    private String email;
    
    /**
     * 最後登入時間（ISO 8601 格式）
     */
    private String lastLoginAt;
}
```

**回應範例**：

```json
{
  "code": 200,
  "message": "查詢成功",
  "data": {
    "userId": 1,
    "username": "admin",
    "tenantId": 1,
    "roles": ["ROLE_ADMIN"],
    "email": "admin@example.com",
    "lastLoginAt": "2025-11-25T10:30:00Z"
  },
  "timestamp": "2025-11-25T10:31:00Z",
  "traceId": "b2c3d4e5-f6a7-8901-bcde-f12345678901"
}
```

---

## 三、JWT Token 結構

### 3.1 Token 格式

**標準 JWT 結構**：`Header.Payload.Signature`

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. (Header)
eyJ1c2VyX2lkIjoxLCJ0ZW5hbnRfaWQiOjEsInVzZXJuYW1lIjoiYWRtaW4iLCJyb2xlcyI6WyJST0xFX0FETUlOIl0sImlhdCI6MTczMjUzNjYwMCwiZXhwIjoxNzMyNjIzMDAwLCJqdGkiOiJhMWIyYzNkNC1lNWY2LTc4OTAtYWJjZC1lZjEyMzQ1Njc4OTAifQ. (Payload)
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c (Signature)
```

### 3.2 Header（標頭）

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **alg**: HMAC-SHA256 演算法
- **typ**: Token 類型（JWT）

### 3.3 Payload（酬載）

```json
{
  "user_id": 1,
  "tenant_id": 1,
  "username": "admin",
  "roles": ["ROLE_ADMIN"],
  "iat": 1732536600,
  "exp": 1732623000,
  "jti": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}
```

**欄位說明**：

| 欄位 | 類型 | 必填 | 說明 | 範例值 |
|------|------|------|------|--------|
| user_id | Long | ✅ | 使用者 ID | 1 |
| tenant_id | Long | ✅ | 租戶 ID | 1 |
| username | String | ✅ | 使用者名稱 | "admin" |
| roles | List<String> | ✅ | 角色列表 | ["ROLE_ADMIN"] |
| iat | Long | ✅ | 簽發時間（Unix timestamp，秒） | 1732536600 |
| exp | Long | ✅ | 過期時間（Unix timestamp，秒） | 1732623000 |
| jti | String | ✅ | JWT ID（UUID，用於黑名單唯一標識） | "a1b2c3d4-..." |

### 3.4 Signature（簽章）

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

- **secret**: 從 `application.yml` 載入（至少 256 位元，例：64 字元 hex 字串）
- **演算法**: HMAC-SHA256

**配置範例**：

```yaml
rbac:
  auth:
    jwt:
      secret: 5a7b3c9d2e4f6a8b1c3d5e7f9a2b4c6d8e0f1a3b5c7d9e2f4a6b8c0d2e4f6a8b # 64 字元 hex (256 bits)
      expiration: 86400 # 24 小時（秒）
```

---

## 四、Redis 資料結構

### 4.1 Token 黑名單

**用途**：儲存已登出或被撤銷的 JWT Token，阻止其繼續使用

**Key Pattern**：

```
auth:blacklist:{jti}
```

**資料類型**：String

**Value**：`"logged_out"` 或 `"revoked"`

**TTL**：Token 剩餘有效期（自動過期，無需手動清理）

**範例**：

```bash
# Redis 命令
SET auth:blacklist:a1b2c3d4-e5f6-7890-abcd-ef1234567890 "logged_out" EX 21600

# 說明：假設 Token 剩餘 6 小時有效（21600 秒），Redis 會在 6 小時後自動刪除此 Key
```

**Java 實作**：

```java
public void addToBlacklist(String jti, Duration remainingValidity) {
    String key = "auth:blacklist:" + jti;
    redisTemplate.opsForValue().set(key, "logged_out", remainingValidity);
}

public boolean isBlacklisted(String jti) {
    String key = "auth:blacklist:" + jti;
    return Boolean.TRUE.equals(redisTemplate.hasKey(key));
}
```

---

### 4.2 帳號鎖定記錄

**用途**：記錄密碼錯誤次數，達到 5 次後鎖定帳號 15 分鐘

**Key Pattern**：

```
auth:lock:{username}
```

**資料類型**：String（儲存 JSON）

**Value 結構**：

```json
{
  "username": "admin",
  "failedAttempts": 5,
  "lockUntil": 1732537500,
  "lastAttemptAt": 1732536600
}
```

**TTL**：900 秒（15 分鐘，鎖定期滿自動解鎖）

**範例**：

```bash
# Redis 命令
SET auth:lock:admin '{"username":"admin","failedAttempts":5,"lockUntil":1732537500,"lastAttemptAt":1732536600}' EX 900
```

**Java 實作**：

```java
@Data
@Builder
public class AccountLockInfo {
    private String username;
    private Integer failedAttempts;
    private Long lockUntil; // Unix timestamp (秒)
    private Long lastAttemptAt; // Unix timestamp (秒)
}

public void recordFailedAttempt(String username) {
    String key = "auth:lock:" + username;
    AccountLockInfo info = getAccountLockInfo(username);
    
    if (info == null) {
        info = AccountLockInfo.builder()
            .username(username)
            .failedAttempts(1)
            .lastAttemptAt(Instant.now().getEpochSecond())
            .build();
    } else {
        info.setFailedAttempts(info.getFailedAttempts() + 1);
        info.setLastAttemptAt(Instant.now().getEpochSecond());
    }
    
    if (info.getFailedAttempts() >= 5) {
        info.setLockUntil(Instant.now().plus(15, ChronoUnit.MINUTES).getEpochSecond());
        redisTemplate.opsForValue().set(key, info, Duration.ofMinutes(15));
    } else {
        redisTemplate.opsForValue().set(key, info, Duration.ofMinutes(15));
    }
}

public boolean isAccountLocked(String username) {
    AccountLockInfo info = getAccountLockInfo(username);
    if (info == null || info.getFailedAttempts() < 5) {
        return false;
    }
    long now = Instant.now().getEpochSecond();
    return info.getLockUntil() != null && now < info.getLockUntil();
}
```

---

## 五、UserContext 介面設計

### 5.1 UserContext（使用者上下文）

**用途**：封裝當前請求的使用者資訊，提供給其他模組使用

```java
package com.rbac.auth.context;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 使用者上下文（不可變物件，執行緒安全）
 * 
 * <p>儲存於 ThreadLocal，由 JwtAuthenticationFilter 設定，供 Service 層存取</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserContext {
    
    /**
     * 使用者 ID
     */
    private Long userId;
    
    /**
     * 使用者名稱
     */
    private String username;
    
    /**
     * 租戶 ID
     */
    private Long tenantId;
    
    /**
     * 使用者角色列表（不可變）
     */
    private List<String> roles;
    
    /**
     * JWT Token ID（用於黑名單檢查）
     */
    private String jti;
    
    /**
     * 檢查使用者是否擁有指定角色
     * 
     * @param role 角色名稱（例：ROLE_ADMIN）
     * @return 若擁有該角色返回 true，否則返回 false
     */
    public boolean hasRole(String role) {
        return roles != null && roles.contains(role);
    }
    
    /**
     * 檢查使用者是否擁有任一指定角色
     * 
     * @param roles 角色名稱陣列
     * @return 若擁有任一角色返回 true，否則返回 false
     */
    public boolean hasAnyRole(String... roles) {
        if (this.roles == null || roles == null) {
            return false;
        }
        return Arrays.stream(roles).anyMatch(this.roles::contains);
    }
}
```

---

### 5.2 UserContextHolder（上下文持有者）

**用途**：使用 ThreadLocal 儲存 UserContext，提供全域存取點

```java
package com.rbac.auth.context;

import com.rbac.common.core.exception.AuthenticationException;

/**
 * UserContext 持有者（ThreadLocal 管理）
 * 
 * <p>由 JwtAuthenticationFilter 設定，Service 層存取，Filter finally 區塊清理</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public class UserContextHolder {
    
    private static final ThreadLocal<UserContext> CONTEXT = new ThreadLocal<>();
    
    /**
     * 設定當前執行緒的使用者上下文
     * 
     * @param context 使用者上下文
     */
    public static void setContext(UserContext context) {
        CONTEXT.set(context);
    }
    
    /**
     * 取得當前執行緒的使用者上下文
     * 
     * @return 使用者上下文
     * @throws AuthenticationException 若未找到使用者上下文
     */
    public static UserContext getContext() {
        UserContext context = CONTEXT.get();
        if (context == null) {
            throw new AuthenticationException("未找到使用者上下文，請確認已登入");
        }
        return context;
    }
    
    /**
     * 取得當前使用者 ID
     * 
     * @return 使用者 ID
     */
    public static Long getCurrentUserId() {
        return getContext().getUserId();
    }
    
    /**
     * 取得當前租戶 ID
     * 
     * @return 租戶 ID
     */
    public static Long getCurrentTenantId() {
        return getContext().getTenantId();
    }
    
    /**
     * 取得當前使用者名稱
     * 
     * @return 使用者名稱
     */
    public static String getCurrentUsername() {
        return getContext().getUsername();
    }
    
    /**
     * 清除當前執行緒的使用者上下文（防止記憶體洩漏）
     * 
     * <p>必須在 Filter 的 finally 區塊呼叫</p>
     */
    public static void clear() {
        CONTEXT.remove();
    }
}
```

---

## 六、Repository 介面設計

### 6.1 UserRepository（使用者倉儲介面）

**用途**：抽象使用者資料存取，支援 Mock 與 JPA 實作切換

```java
package com.rbac.auth.repository;

import com.rbac.auth.model.entity.User;
import java.util.Optional;

/**
 * 使用者倉儲介面
 * 
 * <p>依賴倒置設計：AuthService 依賴此介面，不依賴具體實作</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public interface UserRepository {
    
    /**
     * 根據使用者名稱查詢使用者
     * 
     * @param username 使用者名稱
     * @return 使用者實體（Optional）
     */
    Optional<User> findByUsername(String username);
    
    /**
     * 驗證密碼
     * 
     * @param rawPassword 明文密碼
     * @param encodedPassword BCrypt 編碼後的密碼
     * @return 若密碼正確返回 true，否則返回 false
     */
    boolean validatePassword(String rawPassword, String encodedPassword);
    
    /**
     * 更新最後登入時間
     * 
     * @param userId 使用者 ID
     * @param loginTime 登入時間
     */
    void updateLastLoginTime(Long userId, LocalDateTime loginTime);
}
```

---

### 6.2 MockUserRepository（Mock 實作）

**用途**：初版實作，從 application.yml 載入測試使用者

```java
package com.rbac.auth.repository;

import com.rbac.auth.model.entity.User;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Profile;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Mock 使用者倉儲實作
 * 
 * <p>從 application.yml 載入測試使用者，用於開發環境</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Slf4j
@Repository
@Profile("dev") // 只在 dev Profile 啟用
public class MockUserRepository implements UserRepository {
    
    private final Map<String, User> userMap = new HashMap<>();
    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(10);
    
    public MockUserRepository(MockUsersProperties properties) {
        properties.getMockUsers().forEach(mockUser -> {
            User user = User.builder()
                .userId(mockUser.getUserId())
                .username(mockUser.getUsername())
                .passwordHash(mockUser.getPassword())
                .tenantId(mockUser.getTenantId())
                .roles(mockUser.getRoles())
                .status(UserStatus.ACTIVE)
                .createdAt(LocalDateTime.now())
                .build();
            userMap.put(mockUser.getUsername(), user);
        });
        log.info("Mock 使用者倉儲初始化完成，載入 {} 個測試使用者", userMap.size());
    }
    
    @Override
    public Optional<User> findByUsername(String username) {
        return Optional.ofNullable(userMap.get(username));
    }
    
    @Override
    public boolean validatePassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
    
    @Override
    public void updateLastLoginTime(Long userId, LocalDateTime loginTime) {
        userMap.values().stream()
            .filter(user -> user.getUserId().equals(userId))
            .findFirst()
            .ifPresent(user -> user.setLastLoginAt(loginTime));
    }
}
```

---

## 七、狀態轉換圖

### 7.1 使用者認證狀態

```
┌─────────────┐
│  未認證       │
│ (No Token)   │
└──────┬───────┘
       │ POST /login (成功)
       │ JWT Token 生成
       ▼
┌─────────────┐
│  已認證       │
│ (有效 Token) │
└──────┬───────┘
       │
       ├─ Token 過期 → 返回 401，需重新登入
       ├─ POST /logout → Token 加入黑名單 → 返回未認證
       └─ Token 在黑名單 → 返回 401
```

### 7.2 帳號鎖定狀態

```
┌─────────────┐
│  正常狀態     │
│ (嘗試次數 0) │
└──────┬───────┘
       │ 密碼錯誤 (1-4 次)
       ▼
┌─────────────┐
│  累計錯誤     │
│ (嘗試次數 <5)│
└──────┬───────┘
       │ 密碼錯誤 (第 5 次)
       ▼
┌─────────────┐
│  帳號鎖定     │
│ (鎖定 15 分鐘)│
└──────┬───────┘
       │ 15 分鐘後 Redis TTL 過期
       ▼
┌─────────────┐
│  自動解鎖     │
│ (嘗試次數歸零)│
└──────────────┘
```

---

## 八、資料驗證規則

### 8.1 使用者名稱驗證

- **格式**：3-50 字元，只允許字母、數字、底線
- **正則表達式**：`^[a-zA-Z0-9_]{3,50}$`
- **範例**：
  - ✅ `admin`
  - ✅ `john_doe`
  - ✅ `user123`
  - ❌ `ab` (太短)
  - ❌ `user@example` (包含特殊字元)

### 8.2 密碼驗證

- **格式**：8-128 字元，至少包含一個大寫字母、一個小寫字母、一個數字
- **正則表達式**：`^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d!@#$%^&*()]{8,128}$`
- **範例**：
  - ✅ `Admin123`
  - ✅ `SecurePass123!`
  - ❌ `admin123` (缺少大寫字母)
  - ❌ `ADMIN123` (缺少小寫字母)
  - ❌ `Admin` (太短)

---

## 九、配置範例

### 9.1 application-dev.yml（開發環境）

```yaml
spring:
  profiles:
    active: dev
  data:
    redis:
      host: localhost
      port: 6379
      password: # 留空（本地開發）
      database: 0

rbac:
  auth:
    jwt:
      secret: 5a7b3c9d2e4f6a8b1c3d5e7f9a2b4c6d8e0f1a3b5c7d9e2f4a6b8c0d2e4f6a8b
      expiration: 86400 # 24 小時（秒）
    mock-users:
      - user-id: 1
        username: admin
        password: $2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iAt6Z5EH # admin123
        tenant-id: 1
        roles:
          - ROLE_ADMIN
      - user-id: 2
        username: john
        password: $2a$10$8Z5EHsM8lE9lBOsl7iAt6Z5EHN.zmdr9k7uOCQb376NoUn # SecurePass123!
        tenant-id: 1
        roles:
          - ROLE_USER
```

---

## 總結

本資料模型設計遵循以下原則：

1. **依賴倒置**：UserRepository 介面確保 AuthService 不依賴具體實作
2. **分層清晰**：Entity (Repository) / DTO (Controller) / UserContext (跨層)
3. **不可變性**：UserContext 設計為不可變物件，執行緒安全
4. **Redis 高效**：Token 黑名單與帳號鎖定使用 TTL 自動過期，無需手動清理
5. **JWT 標準**：遵循 RFC 7519，包含必要 Claims (user_id, tenant_id, roles, exp, jti)
6. **Mock 友好**：application.yml 配置測試使用者，支援 Profile 切換

**後續演進**：

- **JpaUserRepository**：當 User Module 完成後，實作 JPA 版本倉儲
- **動態租戶**：整合 Tenant Module 後，tenant_id 從資料庫動態載入
- **動態角色**：整合 Role Module 後，roles 從 sys_user_role 表動態載入
- **權限精細控制**：整合 Permission Module 後，JWT Payload 包含 permissions 欄位

**下一步**：生成 API 合約文件（contracts/）

---

**作者**: CHANG SHOU-WEN, AI-Enhanced | **生成時間**: 2025-11-25
