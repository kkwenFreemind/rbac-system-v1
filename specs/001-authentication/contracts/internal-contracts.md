# Internal Contracts: 認證授權模組

**Branch**: `001-authentication` | **Date**: 2025-11-25 | **Generated By**: `/speckit.plan` Phase 1

---

## 概述

本文件定義 Authentication Module 的內部介面合約，包括 Service 層介面、Repository 層介面、Context 介面及事件定義。這些合約用於模組內部通信與跨模組整合，確保低耦合設計。

**設計原則**：

- **依賴倒置**：高層模組依賴抽象介面，不依賴具體實作
- **介面隔離**：介面職責單一，避免臃腫介面
- **開放封閉**：介面對擴展開放，對修改封閉
- **契約優先**：介面定義先於實作，確保可測試性

---

## 一、Service 層介面

### 1.1 AuthService（認證服務）

**職責**：處理使用者登入、登出及密碼驗證邏輯

```java
package com.rbac.auth.service;

import com.rbac.auth.model.dto.LoginRequest;
import com.rbac.auth.model.dto.LoginResponse;

/**
 * 認證服務介面
 * 
 * <p>提供使用者登入、登出及密碼驗證功能</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public interface AuthService {
    
    /**
     * 使用者登入
     * 
     * <p>驗證帳號密碼，生成 JWT Token，記錄登入日誌</p>
     * 
     * @param request 登入請求
     * @return 登入回應（包含 JWT Token）
     * @throws AuthenticationException 當帳號或密碼錯誤時
     * @throws AccountLockedException 當帳號鎖定時
     */
    LoginResponse login(LoginRequest request);
    
    /**
     * 使用者登出
     * 
     * <p>將 Token 加入黑名單，記錄登出日誌</p>
     * 
     * @param token JWT Token
     * @throws TokenExpiredException 當 Token 已過期時
     * @throws AuthenticationException 當 Token 無效時
     */
    void logout(String token);
    
    /**
     * 驗證密碼
     * 
     * <p>使用 BCrypt 驗證密碼，失敗時累計錯誤次數</p>
     * 
     * @param username 使用者名稱
     * @param rawPassword 明文密碼
     * @return 若密碼正確返回 true，否則返回 false
     */
    boolean validatePassword(String username, String rawPassword);
    
    /**
     * 記錄登入失敗
     * 
     * <p>累計錯誤次數，達到 5 次時鎖定帳號</p>
     * 
     * @param username 使用者名稱
     */
    void recordFailedAttempt(String username);
    
    /**
     * 檢查帳號是否鎖定
     * 
     * @param username 使用者名稱
     * @return 若帳號鎖定返回 true，否則返回 false
     */
    boolean isAccountLocked(String username);
}
```

**使用範例**：

```java
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    
    private final AuthService authService;
    
    @PostMapping("/login")
    public Result<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        LoginResponse response = authService.login(request);
        return Result.success(response, "登入成功");
    }
    
    @PostMapping("/logout")
    public Result<Void> logout(@RequestHeader("Authorization") String authHeader) {
        String token = authHeader.replace("Bearer ", "");
        authService.logout(token);
        return Result.success("登出成功");
    }
}
```

---

### 1.2 JwtTokenService（JWT Token 服務）

**職責**：處理 JWT Token 生成、驗證及 Claims 提取

```java
package com.rbac.auth.service;

import com.rbac.auth.context.UserContext;
import com.rbac.auth.model.entity.User;
import io.jsonwebtoken.Claims;

import java.time.Duration;

/**
 * JWT Token 服務介面
 * 
 * <p>提供 Token 生成、驗證、Claims 提取及黑名單檢查功能</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public interface JwtTokenService {
    
    /**
     * 生成 JWT Token
     * 
     * <p>Payload 包含：user_id, tenant_id, username, roles, iat, exp, jti</p>
     * 
     * @param user 使用者實體
     * @return JWT Token 字串
     */
    String generateToken(User user);
    
    /**
     * 驗證 Token 有效性
     * 
     * <p>檢查簽章、過期時間及黑名單狀態</p>
     * 
     * @param token JWT Token
     * @return 若 Token 有效返回 true，否則返回 false
     */
    boolean validateToken(String token);
    
    /**
     * 從 Token 提取 Claims
     * 
     * @param token JWT Token
     * @return Claims 物件
     * @throws TokenExpiredException 當 Token 已過期時
     * @throws AuthenticationException 當 Token 無效時（簽章錯誤）
     */
    Claims extractClaims(String token);
    
    /**
     * 從 Token 提取 UserContext
     * 
     * @param token JWT Token
     * @return UserContext 物件
     */
    UserContext extractUserContext(String token);
    
    /**
     * 檢查 Token 是否在黑名單
     * 
     * @param jti JWT ID (從 Claims 提取)
     * @return 若在黑名單返回 true，否則返回 false
     */
    boolean isTokenBlacklisted(String jti);
    
    /**
     * 將 Token 加入黑名單
     * 
     * <p>TTL 設定為 Token 剩餘有效期，Redis 自動過期</p>
     * 
     * @param jti JWT ID
     * @param remainingValidity Token 剩餘有效期
     */
    void addToBlacklist(String jti, Duration remainingValidity);
    
    /**
     * 計算 Token 剩餘有效期
     * 
     * @param expirationTime Token 過期時間（Unix timestamp，秒）
     * @return Token 剩餘有效期（Duration）
     */
    Duration calculateRemainingValidity(Long expirationTime);
}
```

**使用範例**：

```java
@Service
public class AuthServiceImpl implements AuthService {
    
    private final JwtTokenService jwtTokenService;
    private final UserRepository userRepository;
    
    @Override
    public LoginResponse login(LoginRequest request) {
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new AuthenticationException("帳號或密碼錯誤"));
        
        if (!userRepository.validatePassword(request.getPassword(), user.getPasswordHash())) {
            recordFailedAttempt(user.getUsername());
            throw new AuthenticationException("帳號或密碼錯誤");
        }
        
        String token = jwtTokenService.generateToken(user);
        return LoginResponse.builder()
            .token(token)
            .userId(user.getUserId())
            .username(user.getUsername())
            .tenantId(user.getTenantId())
            .roles(user.getRoles())
            .build();
    }
}
```

---

## 二、Repository 層介面

### 2.1 UserRepository（使用者倉儲）

**職責**：抽象使用者資料存取，支援 Mock 與 JPA 實作切換

```java
package com.rbac.auth.repository;

import com.rbac.auth.model.entity.User;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * 使用者倉儲介面
 * 
 * <p>依賴倒置設計：AuthService 依賴此介面，不依賴具體實作</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public interface UserRepository {
    
    /**
     * 根據使用者名稱查詢使用者
     * 
     * @param username 使用者名稱
     * @return 使用者實體（Optional）
     */
    Optional<User> findByUsername(String username);
    
    /**
     * 驗證密碼
     * 
     * <p>使用 BCrypt 比對明文密碼與雜湊密碼</p>
     * 
     * @param rawPassword 明文密碼
     * @param encodedPassword BCrypt 編碼後的密碼
     * @return 若密碼正確返回 true，否則返回 false
     */
    boolean validatePassword(String rawPassword, String encodedPassword);
    
    /**
     * 更新最後登入時間
     * 
     * @param userId 使用者 ID
     * @param loginTime 登入時間
     */
    void updateLastLoginTime(Long userId, LocalDateTime loginTime);
}
```

**實作範例**：

```java
// Mock 實作（初版，開發環境）
@Repository
@Profile("dev")
public class MockUserRepository implements UserRepository {
    
    private final Map<String, User> userMap;
    private final BCryptPasswordEncoder passwordEncoder;
    
    @Override
    public Optional<User> findByUsername(String username) {
        return Optional.ofNullable(userMap.get(username));
    }
    
    @Override
    public boolean validatePassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
    
    @Override
    public void updateLastLoginTime(Long userId, LocalDateTime loginTime) {
        userMap.values().stream()
            .filter(user -> user.getUserId().equals(userId))
            .findFirst()
            .ifPresent(user -> user.setLastLoginAt(loginTime));
    }
}

// JPA 實作（後續，生產環境）
@Repository
@Profile("prod")
public class JpaUserRepository implements UserRepository {
    
    private final UserJpaRepository jpaRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    
    @Override
    public Optional<User> findByUsername(String username) {
        return jpaRepository.findByUsername(username);
    }
    
    @Override
    public boolean validatePassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
    
    @Override
    public void updateLastLoginTime(Long userId, LocalDateTime loginTime) {
        jpaRepository.updateLastLoginTime(userId, loginTime);
    }
}
```

---

## 三、Context 介面

### 3.1 UserContext（使用者上下文）

**職責**：封裝當前請求的使用者資訊，提供給其他模組使用

```java
package com.rbac.auth.context;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Arrays;
import java.util.List;

/**
 * 使用者上下文（不可變物件，執行緒安全）
 * 
 * <p>儲存於 ThreadLocal，由 JwtAuthenticationFilter 設定，供 Service 層存取</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserContext {
    
    /** 使用者 ID */
    private Long userId;
    
    /** 使用者名稱 */
    private String username;
    
    /** 租戶 ID */
    private Long tenantId;
    
    /** 使用者角色列表（不可變） */
    private List<String> roles;
    
    /** JWT Token ID（用於黑名單檢查） */
    private String jti;
    
    /**
     * 檢查使用者是否擁有指定角色
     * 
     * @param role 角色名稱（例：ROLE_ADMIN）
     * @return 若擁有該角色返回 true，否則返回 false
     */
    public boolean hasRole(String role) {
        return roles != null && roles.contains(role);
    }
    
    /**
     * 檢查使用者是否擁有任一指定角色
     * 
     * @param roles 角色名稱陣列
     * @return 若擁有任一角色返回 true，否則返回 false
     */
    public boolean hasAnyRole(String... roles) {
        if (this.roles == null || roles == null) {
            return false;
        }
        return Arrays.stream(roles).anyMatch(this.roles::contains);
    }
}
```

---

### 3.2 UserContextHolder（上下文持有者）

**職責**：使用 ThreadLocal 儲存 UserContext，提供全域存取點

```java
package com.rbac.auth.context;

import com.rbac.common.core.exception.AuthenticationException;

/**
 * UserContext 持有者（ThreadLocal 管理）
 * 
 * <p>由 JwtAuthenticationFilter 設定，Service 層存取，Filter finally 區塊清理</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public class UserContextHolder {
    
    private static final ThreadLocal<UserContext> CONTEXT = new ThreadLocal<>();
    
    /**
     * 設定當前執行緒的使用者上下文
     * 
     * @param context 使用者上下文
     */
    public static void setContext(UserContext context) {
        CONTEXT.set(context);
    }
    
    /**
     * 取得當前執行緒的使用者上下文
     * 
     * @return 使用者上下文
     * @throws AuthenticationException 若未找到使用者上下文
     */
    public static UserContext getContext() {
        UserContext context = CONTEXT.get();
        if (context == null) {
            throw new AuthenticationException("未找到使用者上下文，請確認已登入");
        }
        return context;
    }
    
    /**
     * 取得當前使用者 ID
     * 
     * @return 使用者 ID
     */
    public static Long getCurrentUserId() {
        return getContext().getUserId();
    }
    
    /**
     * 取得當前租戶 ID
     * 
     * @return 租戶 ID
     */
    public static Long getCurrentTenantId() {
        return getContext().getTenantId();
    }
    
    /**
     * 取得當前使用者名稱
     * 
     * @return 使用者名稱
     */
    public static String getCurrentUsername() {
        return getContext().getUsername();
    }
    
    /**
     * 清除當前執行緒的使用者上下文（防止記憶體洩漏）
     * 
     * <p>必須在 Filter 的 finally 區塊呼叫</p>
     */
    public static void clear() {
        CONTEXT.remove();
    }
}
```

**使用範例**：

```java
// Filter 中設定 UserContext
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    private final JwtTokenService jwtTokenService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain chain) throws ServletException, IOException {
        try {
            String token = extractToken(request);
            if (token != null && jwtTokenService.validateToken(token)) {
                UserContext context = jwtTokenService.extractUserContext(token);
                UserContextHolder.setContext(context);
            }
            chain.doFilter(request, response);
        } finally {
            UserContextHolder.clear(); // ✅ 防止記憶體洩漏
        }
    }
}

// Service 層存取 UserContext
@Service
public class TenantService {
    
    public List<Tenant> getTenantsByCurrentUser() {
        Long tenantId = UserContextHolder.getCurrentTenantId(); // 從 Auth Module 取得 tenant_id
        return tenantRepository.findByTenantId(tenantId);
    }
}
```

---

## 四、事件定義

### 4.1 LoginSuccessEvent（登入成功事件）

**職責**：通知 Audit Module 記錄登入成功日誌

```java
package com.rbac.auth.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 登入成功事件
 * 
 * <p>發布給 Audit Module 記錄登入日誌</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginSuccessEvent {
    
    /** 使用者 ID */
    private Long userId;
    
    /** 使用者名稱 */
    private String username;
    
    /** 租戶 ID */
    private Long tenantId;
    
    /** 登入 IP 位址 */
    private String ipAddress;
    
    /** 登入時間 */
    private LocalDateTime loginTime;
    
    /** User-Agent（瀏覽器資訊） */
    private String userAgent;
}
```

**發布方式**：

```java
@Service
public class AuthServiceImpl implements AuthService {
    
    private final ApplicationEventPublisher eventPublisher;
    
    @Override
    public LoginResponse login(LoginRequest request) {
        // ... 驗證邏輯 ...
        
        // 發布登入成功事件
        LoginSuccessEvent event = LoginSuccessEvent.builder()
            .userId(user.getUserId())
            .username(user.getUsername())
            .tenantId(user.getTenantId())
            .ipAddress(getClientIp())
            .loginTime(LocalDateTime.now())
            .userAgent(getUserAgent())
            .build();
        
        eventPublisher.publishEvent(event);
        
        return loginResponse;
    }
}
```

---

### 4.2 LogoutEvent（登出事件）

**職責**：通知 Audit Module 記錄登出日誌

```java
package com.rbac.auth.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 登出事件
 * 
 * <p>發布給 Audit Module 記錄登出日誌</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LogoutEvent {
    
    /** 使用者 ID */
    private Long userId;
    
    /** 使用者名稱 */
    private String username;
    
    /** 租戶 ID */
    private Long tenantId;
    
    /** JWT Token ID（已加入黑名單） */
    private String jti;
    
    /** 登出時間 */
    private LocalDateTime logoutTime;
    
    /** 登出 IP 位址 */
    private String ipAddress;
}
```

---

### 4.3 PermissionDeniedEvent（權限拒絕事件）

**職責**：通知 Audit Module 記錄權限驗證失敗日誌

```java
package com.rbac.auth.event;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 權限拒絕事件
 * 
 * <p>發布給 Audit Module 記錄權限驗證失敗日誌</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionDeniedEvent {
    
    /** 使用者 ID */
    private Long userId;
    
    /** 使用者名稱 */
    private String username;
    
    /** 租戶 ID */
    private Long tenantId;
    
    /** 請求的權限碼 */
    private String requiredPermission;
    
    /** 使用者擁有的角色列表 */
    private List<String> userRoles;
    
    /** 拒絕時間 */
    private LocalDateTime deniedTime;
    
    /** 請求的 API 端點 */
    private String requestedEndpoint;
}
```

---

## 五、跨模組整合合約

### 5.1 UserContext API（供其他模組使用）

**提供方**：Auth Module

**使用方**：Tenant Module, User Module, Permission Module, Audit Module

**合約**：

```java
/**
 * 跨模組整合：UserContext API
 * 
 * <p>其他模組透過 UserContextHolder 取得當前使用者資訊</p>
 */

// 取得當前使用者 ID
Long userId = UserContextHolder.getCurrentUserId();

// 取得當前租戶 ID（用於租戶隔離）
Long tenantId = UserContextHolder.getCurrentTenantId();

// 取得當前使用者名稱
String username = UserContextHolder.getCurrentUsername();

// 取得完整 UserContext
UserContext context = UserContextHolder.getContext();

// 檢查使用者是否擁有角色
boolean isAdmin = context.hasRole("ROLE_ADMIN");
boolean hasPermission = context.hasAnyRole("ROLE_ADMIN", "ROLE_MANAGER");
```

**注意事項**：

1. **執行緒安全**：UserContext 儲存於 ThreadLocal，只在當前請求執行緒有效
2. **異步場景**：若需在 @Async 方法中使用，需使用 TaskDecorator 傳遞上下文
3. **清理責任**：由 Auth Module 的 JwtAuthenticationFilter 負責清理，其他模組無需手動清理

---

### 5.2 權限校驗 API（供其他模組使用）

**提供方**：Auth Module

**使用方**：所有業務模組

**合約**：

```java
/**
 * 跨模組整合：權限校驗 API
 * 
 * <p>其他模組透過 @PreAuthorize 註解進行權限校驗</p>
 */

// 方法級權限校驗
@Service
public class TenantService {
    
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public void deleteTenant(Long tenantId) {
        // 只有 ADMIN 角色可執行
    }
    
    @PreAuthorize("hasRole('ROLE_USER') and #tenantId == principal.tenantId")
    public Tenant getTenant(Long tenantId) {
        // USER 角色只能查詢自己的租戶
    }
    
    @PreAuthorize("hasPermission(#tenantId, 'TENANT', 'UPDATE')")
    public void updateTenant(Long tenantId, TenantUpdateRequest request) {
        // 使用自訂 PermissionEvaluator 檢查資料權限
    }
}
```

**啟用方式**：

```java
@Configuration
@EnableMethodSecurity(prePostEnabled = true) // Spring Security 6+
public class SecurityConfig {
    // ...
}
```

---

## 六、異常定義

### 6.1 AuthenticationException（認證異常）

```java
package com.rbac.auth.exception;

import com.rbac.common.core.exception.BaseException;

/**
 * 認證異常
 * 
 * <p>當使用者認證失敗時拋出（帳號密碼錯誤、Token 無效等）</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public class AuthenticationException extends BaseException {
    
    public AuthenticationException(String message) {
        super(401, message);
    }
    
    public AuthenticationException(String message, Throwable cause) {
        super(401, message, cause);
    }
}
```

---

### 6.2 TokenExpiredException（Token 過期異常）

```java
package com.rbac.auth.exception;

import com.rbac.common.core.exception.BaseException;

/**
 * Token 過期異常
 * 
 * <p>當 JWT Token 已過期時拋出</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public class TokenExpiredException extends BaseException {
    
    public TokenExpiredException(String message) {
        super(401, message);
    }
}
```

---

### 6.3 AccountLockedException（帳號鎖定異常）

```java
package com.rbac.auth.exception;

import com.rbac.common.core.exception.BaseException;

import java.time.Duration;

/**
 * 帳號鎖定異常
 * 
 * <p>當帳號因密碼錯誤 5 次被鎖定時拋出</p>
 * 
 * @author CHANG SHOU-WEN, AI-Enhanced
 * @since 2025/11/25
 */
public class AccountLockedException extends BaseException {
    
    private final Long lockUntil; // Unix timestamp (秒)
    
    public AccountLockedException(String message, Long lockUntil) {
        super(403, message);
        this.lockUntil = lockUntil;
    }
    
    public Long getLockUntil() {
        return lockUntil;
    }
    
    public Duration getRemainingLockTime() {
        long now = Instant.now().getEpochSecond();
        long remaining = lockUntil - now;
        return Duration.ofSeconds(Math.max(0, remaining));
    }
}
```

---

## 七、合約驗證

### 7.1 單元測試範例

```java
@ExtendWith(MockitoExtension.class)
class AuthServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private JwtTokenService jwtTokenService;
    
    @InjectMocks
    private AuthServiceImpl authService;
    
    @Test
    @DisplayName("登入成功應返回 JWT Token")
    void testLoginSuccess() {
        // Given
        LoginRequest request = new LoginRequest("admin", "admin123");
        User mockUser = User.builder()
            .userId(1L)
            .username("admin")
            .passwordHash("$2a$10$...")
            .tenantId(1L)
            .roles(List.of("ROLE_ADMIN"))
            .build();
        
        when(userRepository.findByUsername("admin")).thenReturn(Optional.of(mockUser));
        when(userRepository.validatePassword("admin123", "$2a$10$...")).thenReturn(true);
        when(jwtTokenService.generateToken(mockUser)).thenReturn("mock-jwt-token");
        
        // When
        LoginResponse response = authService.login(request);
        
        // Then
        assertThat(response.getToken()).isEqualTo("mock-jwt-token");
        assertThat(response.getUserId()).isEqualTo(1L);
        assertThat(response.getUsername()).isEqualTo("admin");
        verify(userRepository).updateLastLoginTime(eq(1L), any(LocalDateTime.class));
    }
    
    @Test
    @DisplayName("密碼錯誤應拋出 AuthenticationException")
    void testLoginFailedWithWrongPassword() {
        // Given
        LoginRequest request = new LoginRequest("admin", "wrong-password");
        User mockUser = User.builder()
            .username("admin")
            .passwordHash("$2a$10$...")
            .build();
        
        when(userRepository.findByUsername("admin")).thenReturn(Optional.of(mockUser));
        when(userRepository.validatePassword("wrong-password", "$2a$10$...")).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> authService.login(request))
            .isInstanceOf(AuthenticationException.class)
            .hasMessage("帳號或密碼錯誤");
        
        verify(authService).recordFailedAttempt("admin");
    }
}
```

---

## 八、總結

本內部合約文件定義 Authentication Module 的核心介面，確保：

1. **依賴倒置**：AuthService 依賴 UserRepository/JwtTokenService 介面，不依賴具體實作
2. **介面隔離**：每個介面職責單一（AuthService 負責認證邏輯，JwtTokenService 負責 Token 操作）
3. **跨模組整合**：UserContextHolder 提供統一 API 供其他模組使用
4. **事件驅動**：LoginSuccessEvent/LogoutEvent 解耦 Auth Module 與 Audit Module
5. **契約優先**：介面定義明確，支援 TDD 開發流程

**後續演進**：

- **PermissionEvaluator**：實作自訂權限評估器，支援 `hasPermission()` 表達式
- **RefreshTokenService**：新增 Refresh Token 介面，支援 Token 續期
- **OAuth2 整合**：新增 OAuth2Service 介面，支援第三方登入

**下一步**：生成 quickstart.md

---

**作者**: CHANG SHOU-WEN, AI-Enhanced | **生成時間**: 2025-11-25
