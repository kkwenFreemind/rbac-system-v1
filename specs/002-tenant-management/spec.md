# 功能規格：租戶管理模組

**功能分支**: `002-tenant-management`  
**建立日期**: 2025-11-24  
**更新日期**: 2025-11-25  
**狀態**: ✅ READY - Authentication Module 已完成  
**輸入**: 使用者描述：「租戶模組包含 CRUD 操作、TenantContextHolder 用於租戶上下文管理、TenantFilter 用於自動注入 tenant_id，以及行級隔離策略實作」

---

## ✅ Prerequisites Completed: Authentication Module

**Status**: ✅ **READY** - 認證模組已完成並合併到 master

### 已滿足的前置條件

租戶管理模組的核心功能依賴於認證模組提供的以下能力：

1. **JWT Token 包含 tenant_id**：TenantFilter 需要從 JWT 提取租戶 ID
2. **UserContext 介面**：稽核欄位（created_by, updated_by）需要當前使用者資訊
3. **權限驗證框架**：租戶 CRUD 操作需要 `tenant:create/read/update/delete` 權限
4. **已認證會話**：TenantContextHolder 僅對已認證使用者有效

### 前置需求檢查清單

Authentication Module 已完成以下功能：

- [X] **AUTH-001** JWT Token 生成/驗證（包含 `tenant_id` claim）
- [X] **AUTH-002** UserContext 實作（提供 `getCurrentUser()` 和 `getTenantId()`）
- [X] **AUTH-003** 登入/登出 API 端點（POST /api/v1/auth/login, /logout）
- [X] **AUTH-004** Spring Security @PreAuthorize 註解支援
- [X] **AUTH-005** Redis Session 管理（Token 黑名單）

**Auth Module 實際開發時間**: 3 天（已完成並合併到 master）

### 下一步行動

1. ✅ Auth Module 規格設計完成
2. ✅ Auth Module 實作完成
3. ✅ Auth Module 合併到 master
4. ➡️ **開始租戶模組實作**（當前分支：002-tenant-management）

---

## 使用者場景與測試 *(必填)*

### 使用者故事 1 - 平台管理員建立新租戶組織 (優先順序：P1)

平台管理員需要將新的客戶組織加入多租戶系統。他們建立包含必要資訊（名稱、聯絡資訊、方案類型）的租戶記錄，並啟用它以供立即使用。

**為何此優先順序**：這是基礎操作 - 沒有建立租戶的能力，其他租戶操作都無法運作。這代表所有客戶組織進入系統的入口點。

**獨立測試**：可以透過管理介面建立租戶來完整測試，驗證租戶出現在系統中並具有唯一識別碼，並確認租戶立即可用於使用者指派和資料操作。

**驗收場景**：

1. **假設** 我是平台管理員，**當** 我建立一個新租戶，名稱為「Acme Corp」，聯絡電子郵件為「<admin@acme.com>」，方案為「Enterprise」，**則** 系統建立一個具有有效 tenant_id 和狀態為「Active」的唯一租戶
2. **假設** 我正在建立新租戶，**當** 我提交包含所有必填欄位的表單，**則** 系統在 2 秒內返回已建立的租戶及其唯一識別碼
3. **假設** 名稱為「Acme Corp」的租戶已存在，**當** 我嘗試建立另一個相同名稱的租戶，**則** 系統阻止建立並返回清楚的錯誤訊息

---

### 使用者故事 2 - 自動租戶上下文注入以實現資料隔離 (優先順序：P1)

當任何使用者向系統發出請求時，租戶上下文會自動被識別並注入到所有後續的資料庫操作中，無需在業務邏輯中手動進行租戶過濾。這確保了租戶之間的完整資料隔離。

**為何此優先順序**：這對多租戶系統的安全性和資料完整性至關重要。沒有自動上下文注入，就有跨租戶資料洩漏的風險。這必須在執行任何業務操作之前正確運作。

**獨立測試**：可以透過以不同租戶的使用者身份登入、執行 CRUD 操作，並驗證每個使用者只能看到屬於其租戶的資料來測試。資料庫查詢應自動包含 tenant_id 過濾器，無需顯式程式碼。

**驗收場景**：

1. **假設** 使用者 A 屬於租戶 1，使用者 B 屬於租戶 2，**當** 兩個使用者同時列出記錄，**則** 使用者 A 只看到租戶 1 的資料，使用者 B 只看到租戶 2 的資料
2. **假設** 使用者已通過身份驗證並設定了租戶上下文，**當** 使用者建立新記錄時未顯式設定 tenant_id，**則** 系統自動將使用者的 tenant_id 指派給新記錄
3. **假設** 使用者進行多個連續請求，**當** 每個請求完成時，**則** 租戶上下文被正確清理，以防止執行緒池中的上下文污染
4. **假設** 來自租戶 1 的使用者嘗試透過 ID 存取屬於租戶 2 的資料，**當** 查詢執行時，**則** 系統返回「未找到」而不是暴露跨租戶資料

---

### 使用者故事 3 - 平台管理員更新租戶資訊 (優先順序：P2)

平台管理員需要更新租戶資訊，例如聯絡資訊、方案升級/降級，或隨著客戶關係發展而改變狀態（啟用/暫停）。

**為何此優先順序**：雖然對持續的租戶管理很重要，但這可以在初始租戶建立後延遲。組織可以在需要更新之前使用初始設定運作。

**獨立測試**：可以透過建立租戶、修改其屬性（名稱、方案、狀態），並驗證變更持久化並立即對租戶操作生效來測試。

**驗收場景**：

1. **假設** 存在一個啟用的租戶，**當** 我將租戶的方案從「Basic」更新為「Enterprise」，**則** 變更被儲存並立即反映
2. **假設** 需要暫時停用租戶，**當** 我將狀態變更為「Suspended」，**則** 屬於該租戶的所有使用者收到適當的存取限制
3. **假設** 我正在更新租戶聯絡資訊，**當** 我提交有效的變更，**則** 稽核記錄記錄了誰在何時進行了變更

---

### 使用者故事 4 - 平台管理員檢視租戶清單和詳細資訊 (優先順序：P2)

平台管理員需要檢視系統中的所有租戶，具有過濾和分頁功能，並存取任何特定租戶的詳細資訊，包括使用者數量和活動指標。

**為何此優先順序**：對系統管理和監控至關重要，但讀取操作可以在核心建立/更新功能運作後實作。

**獨立測試**：可以透過建立多個租戶並驗證清單檢視顯示所有租戶，具有正確的過濾、排序和分頁來測試。詳細檢視應顯示全面的租戶資訊。

**驗收場景**：

1. **假設** 系統有 50 個租戶，**當** 我請求租戶清單並分頁（每頁 10 個），**則** 我收到前 10 個租戶及總計數和導航元資料
2. **假設** 我想找到特定租戶，**當** 我按租戶名稱「Acme」過濾，**則** 只返回符合過濾條件的租戶
3. **假設** 我選擇特定租戶，**當** 我檢視租戶詳細資訊，**則** 我看到租戶資訊、使用者數量、建立日期和目前狀態

---

### 使用者故事 5 - 平台管理員軟刪除租戶 (優先順序：P3)

當客戶關係結束時，平台管理員需要停用租戶，使用軟刪除來維護資料完整性和稽核歷史記錄，同時防止主動使用。

**為何此優先順序**：這對初始系統運作較不重要。租戶停用/暫停（透過狀態變更）可以處理大多數即時需求。軟刪除對長期資料管理很重要，但可以在核心操作穩定後實作。

**獨立測試**：可以透過軟刪除租戶並驗證它不再出現在啟用清單中，但仍保留在資料庫中並帶有已刪除標記來測試。先前關聯的資料應保持完整以供稽核。

**驗收場景**：

1. **假設** 存在一個啟用的租戶，**當** 我軟刪除該租戶，**則** 租戶被標記為已刪除並附上時間戳，但仍保留在資料庫中
2. **假設** 租戶已被軟刪除，**當** 該租戶的使用者嘗試登入，**則** 他們收到適當的訊息，表明其組織帳戶不再啟用
3. **假設** 租戶已被軟刪除，**當** 我查詢啟用的租戶清單，**則** 已刪除的租戶不會出現在結果中

---

### 邊界案例

- **並行租戶建立**：當兩個管理員同時嘗試建立相同名稱的租戶時會發生什麼？系統應使用資料庫級唯一約束來防止重複，並向第二個請求者返回清楚的錯誤。

- **缺少租戶上下文**：系統如何處理無法確定租戶上下文的請求？系統應拒絕請求並返回清楚的錯誤，指出需要身份驗證/授權。

- **租戶上下文清理失敗**：如果執行緒上下文清理因異常而失敗會發生什麼？系統應實作多層清理策略（過濾器、攔截器）並記錄清理失敗以供監控。

- **跨租戶資料存取嘗試**：系統如何防止惡意使用者在請求中操縱 tenant_id？系統應僅從已驗證的使用者會話中衍生 tenant_id，絕不從請求參數中取得。

- **已刪除租戶的孤立資料**：當租戶被軟刪除時，資料會發生什麼？資料應保留在資料庫中，租戶關係保持完整以供稽核和潛在恢復，但無法透過正常操作存取。

- **高流量並行操作**：系統如何處理來自不同租戶的 1000+ 個並行請求？租戶上下文應使用 ThreadLocal 進行執行緒安全隔離，而不會影響效能。

- **租戶狀態轉換**：有效的狀態轉換是什麼，當嘗試無效轉換時會發生什麼？系統應強制執行有效的狀態機（例如，Active → Suspended → Active，但不是 Deleted → Active，除非有明確的恢復流程）。

## 需求 *(必填)*

### 功能需求

- **FR-001**：系統必須提供租戶實體的建立、讀取、更新和軟刪除操作
- **FR-002**：系統必須使用全域唯一 ID 策略為每個新租戶生成唯一的租戶識別碼
- **FR-003**：系統必須在建立前驗證租戶名稱是唯一且非空的
- **FR-004**：系統必須在儲存前驗證租戶聯絡電子郵件格式
- **FR-005**：系統必須支援租戶狀態值：Active、Suspended、Deleted
- **FR-006**：系統必須為每個請求自動從已驗證的使用者會話中提取租戶上下文
- **FR-007**：系統必須在所有資料庫 SELECT 查詢中注入 tenant_id 過濾器，無需顯式業務邏輯
- **FR-008**：系統必須在所有資料庫 INSERT 操作中自動設定 tenant_id，無需顯式業務邏輯
- **FR-009**：系統必須防止任何 UPDATE 或 DELETE 操作影響屬於不同租戶的記錄
- **FR-010**：系統必須在每個請求完成後從 ThreadLocal 儲存中清理租戶上下文
- **FR-011**：系統必須即使在請求處理拋出異常時也要清理租戶上下文
- **FR-012**：系統必須實作多層清理策略（過濾器和攔截器）以進行防禦性編程
- **FR-013**：系統必須為所有租戶操作記錄稽核資訊（created_by、created_at、updated_by、updated_at）
- **FR-014**：系統必須支援租戶清單查詢的分頁，具有可配置的頁面大小
- **FR-015**：系統必須支援按名稱、狀態和日期範圍過濾租戶清單
- **FR-016**：系統必須防止硬刪除租戶記錄以維護稽核追蹤
- **FR-017**：系統必須從標準查詢結果中排除軟刪除的租戶，除非明確請求
- **FR-018**：系統必須在 debug 級別記錄所有租戶上下文操作（set、get、clear）以供故障排除
- **FR-019**：系統必須在租戶詳細檢視中提供租戶計數和使用者計數指標
- **FR-020**：系統必須在租戶操作驗證失敗時返回適當的錯誤訊息

### 關鍵實體

- **Tenant（租戶）**：代表多租戶系統中的客戶組織。關鍵屬性包括唯一識別碼、組織名稱、聯絡電子郵件、訂閱方案類型、狀態（Active/Suspended/Deleted）、建立和修改時間戳，以及軟刪除標記。每個租戶都透過自動行級安全性進行隔離。

- **TenantContext（租戶上下文）**：代表請求處理的當前租戶範圍。包含儲存在執行緒本地儲存中的 tenant_id 值，確保並行操作中的執行緒安全隔離。自動從已驗證的使用者會話中設定，並在請求完成後清除。

## 成功標準 *(必填)*

### 可衡量的結果

- **SC-001**：平台管理員可以在收到客戶資訊後 30 秒內建立新租戶並啟用它
- **SC-002**：系統處理來自 50 個不同租戶的使用者的 1000 個並行請求，且不會發生跨租戶資料洩漏
- **SC-003**：100% 的資料庫查詢自動包含 tenant_id 過濾，無需顯式業務邏輯
- **SC-004**：在使用執行緒池進行 10,000 個請求的 24 小時壓力測試中，ThreadLocal 記憶體洩漏為零
- **SC-005**：租戶上下文清理在包括錯誤場景在內的 99.99% 請求中成功執行
- **SC-006**：租戶清單查詢在 1000 個租戶的資料集中，分頁返回結果在 500 毫秒內
- **SC-007**：系統在安全測試中以 100% 成功率防止跨租戶資料存取嘗試
- **SC-008**：管理操作（建立、更新、刪除）在正常負載下 2 秒內完成
- **SC-009**：軟刪除的租戶被排除在啟用查詢之外，同時仍可供稽核目的存取
- **SC-010**：系統維護所有租戶修改的完整稽核追蹤，包含時間戳和使用者歸屬

## 假設

- 租戶上下文衍生自已驗證的使用者會話（JWT 或基於會話的身份驗證已在 Common Layer 中實作）
- 資料庫透過 ORM 攔截器機制支援行級過濾（MyBatis-Plus TenantLineInnerInterceptor 已在 Common Database 模組中配置）
- ThreadLocal 清理由現有的 Common Web 模組過濾器和攔截器處理
- 唯一租戶識別使用 BaseEntity 中已可用的 Snowflake ID 生成
- 標準分頁參數（頁碼、頁面大小）遵循現有的 PageRequest/PageResponse 模式
- 稽核欄位填充（created_by、updated_by）使用 Common Database 模組中現有的 AuditMetaObjectHandler
- HTTP 請求包含適當的身份驗證標頭以供租戶上下文提取
- 軟刪除使用 Common Database 模組中現有的邏輯刪除機制（@TableLogic）
- 管理員使用者具有系統級權限，可以跨所有租戶執行租戶管理操作
- 租戶清單的預設頁面大小為每頁 20 條記錄，除非另有指定

## 依賴項

- **Common Core 模組**：提供 Result、異常處理、UserContext 介面和驗證工具
- **Common Database 模組**：提供 TenantEntity、AuditEntity、TenantContextHolder、MyBatis 租戶攔截器和稽核欄位處理器
- **Common Web 模組**：提供 TenantFilter 用於自動上下文注入、GlobalExceptionHandler 和請求/回應處理
- **Authentication 模組**：必須提供包含 tenant_id 的已驗證使用者資訊（假設已實作或將與此功能一起實作）
